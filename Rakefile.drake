
$LOAD_PATH.unshift "./contrib/comp_tree/contrib/quix/lib"

require 'quix/subpackager'
require 'quix/fileutils'
require 'fileutils'

######################################################################
# git

def git(*args)
  cmd = ["git"] + args
  sh(*cmd)
end

task :add_contrib_first_time => :init_contrib do
  git(*%w!merge --squash -s ours --no-commit comp_tree/master!)
  git(*%w!read-tree --prefix=contrib/comp_tree -u comp_tree/master!)
  git("commit", "-m", "add comp_tree package")
end

task :init_contrib do
  unless `git remote`.split.include? "comp_tree"
    git(*%w!remote add -f comp_tree git@github.com:quix/comp_tree.git!)
  end
end

task :run_pull_contrib => :init_contrib do
  git(*%w!pull --no-commit -s subtree comp_tree master!)
end

task :pull_mainline do
  git(*%w!pull --no-commit
          git://github.com/jimweirich/rake.git
          refs/heads/master:refs/heads/origin!)
end

task :pull_contrib => [ :init_contrib, :run_pull_contrib ]

######################################################################
# drake_release

task :drake_prerelease => :clean do
  rm_rf("html")
  rm_rf("pkg")
  unless `git status` =~ %r!nothing to commit \(working directory clean\)!
    raise "Directory not clean"
  end
end

task :drake_publish => :rdoc do
  Dir.chdir("html") {
    sh(*%w(scp -r . quix@rubyforge.org:/var/www/gforge-projects/drake))
  }
end

def rubyforge(command, file)
  sh("rubyforge",
     command,
     SPEC.rubyforge_project,
     SPEC.rubyforge_project,
     SPEC.version.to_s,
     file)
end

task :drake_finish_release do
  sh("rubyforge", "login")
  Dir.chdir("pkg") {
    gem = "#{SPEC.name}-#{SPEC.version}.gem"
    md5 = "#{gem}.md5"
    sh("md5sum #{gem} > #{md5}")
    rubyforge("add_release", gem)
    rubyforge("add_file", md5)
  }

  git("tag", "drake-" + SPEC.version.to_s)
  git("push", "--tags")
end

task :drake_release =>
  [
   :drake_prerelease,
   :gem,
   :test_all,
   :drake_publish,
   :drake_finish_release,
  ]

